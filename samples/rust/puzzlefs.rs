// SPDX-License-Identifier: GPL-2.0

//! Rust file system sample.

use kernel::module_fs;
use kernel::prelude::*;
use kernel::{
    c_str, file, fs,
    io_buffer::IoBufferWriter,
    str::CString,
    sync::{Arc, ArcBorrow},
    types::ARef,
};

mod puzzle;
use puzzle::inode::{file_read, PuzzleFS};
use puzzle::types::{DirEnt, Inode, InodeMode};
// Required by the autogenerated '_capnp.rs' files
use puzzle::{manifest_capnp, metadata_capnp};

use kernel::fs::{INodeParams, NeedsRoot, NewSuperBlock, RootDEntry};

module_fs! {
    type: PuzzleFsModule,
    name: "puzzlefs",
    author: "Ariel Miculas",
    license: "GPL",
}

struct PuzzleFsModule;

struct PuzzlefsInfo {
    puzzlefs: Arc<PuzzleFS>,
}

#[derive(Default)]
struct PuzzleFsParams {
    oci_root_dir: Option<CString>,
    image_manifest: Option<CString>,
}

#[vtable]
impl fs::Context<Self> for PuzzleFsModule {
    type Data = Box<PuzzleFsParams>;

    kernel::define_fs_params! {Box<PuzzleFsParams>,
        {string, "oci_root_dir", |s, v| {
                                      s.oci_root_dir = Some(CString::try_from_fmt(format_args!("{v}"))?);
                                      Ok(())
                                  }},
        {string, "image_manifest", |s, v| {
                                      s.image_manifest = Some(CString::try_from_fmt(format_args!("{v}"))?);
                                      Ok(())
                                  }},
    }

    fn try_new() -> Result<Self::Data> {
        Ok(Box::try_new(PuzzleFsParams::default())?)
    }
}

struct PuzzlefsInodeOperations;
#[vtable]
impl fs::InodeOperations<PuzzleFsModule> for PuzzlefsInodeOperations {
    fn lookup(
        sb: &fs::SuperBlock<PuzzleFsModule>,
        pfs_info: &PuzzlefsInfo,
        parent: &Arc<Inode>,
        name: &[u8],
        _flags: u32,
    ) -> Result<ARef<fs::INode<PuzzleFsModule>>> {
        let ino = parent.dir_lookup(name)?;
        let inode = Arc::try_new(pfs_info.puzzlefs.find_inode(ino)?)?;
        let result = match &inode.mode {
            InodeMode::File { chunks: _ } => {
                let params = INodeParams {
                    mode: inode.permissions,
                    ino: inode.ino,
                    value: inode.clone(),
                };
                sb.try_new_file_inode::<FsFile>(params)
            }
            InodeMode::Dir { dir_list: _ } => {
                let params = INodeParams {
                    mode: inode.permissions,
                    ino: inode.ino,
                    value: inode.clone(),
                };

                sb.try_new_dir_inode::<PuzzlefsInodeOperations, FsDir>(params)
            }
            _ => todo!(),
        };
        result
    }
}

/// Creates a new root dentry populated with the given entries.
fn try_new_populated_root_puzzlefs_dentry(
    sb: &NewSuperBlock<'_, PuzzleFsModule, NeedsRoot>,
    root_value: <PuzzleFsModule as fs::Type>::INodeData,
) -> Result<RootDEntry<PuzzleFsModule>> {
    let root_inode = sb
        .sb
        .try_new_dir_inode::<PuzzlefsInodeOperations, FsDir>(INodeParams {
            mode: 0o755,
            ino: root_value.ino,
            value: root_value,
        })?;
    let root = sb.try_new_root_dentry(root_inode)?;
    Ok(root)
}

impl fs::Type for PuzzleFsModule {
    type Context = Self;
    // this is Arc so it can be cloned in lookup
    type INodeData = Arc<Inode>;
    type Data = Box<PuzzlefsInfo>;
    const SUPER_TYPE: fs::Super = fs::Super::Independent;
    const NAME: &'static CStr = c_str!("puzzlefs");
    const FLAGS: i32 = fs::flags::USERNS_MOUNT;
    const DCACHE_BASED: bool = true;

    fn fill_super(
        data: Box<PuzzleFsParams>,
        sb: fs::NewSuperBlock<'_, Self>,
    ) -> Result<&fs::SuperBlock<Self>> {
        let Some(oci_root_dir) = data.oci_root_dir else {
                pr_err!("missing oci_root_dir parameter!\n");
                return Err(ENOTSUPP);
        };

        let Some(image_manifest) = data.image_manifest else {
                pr_err!("missing image_manifest parameter!\n");
                return Err(ENOTSUPP);
        };

        let puzzlefs = PuzzleFS::open(&oci_root_dir, &image_manifest);

        if let Err(ref e) = puzzlefs {
            pr_info!("error opening puzzlefs {e}\n");
        }

        let puzzlefs = Arc::try_new(puzzlefs?)?;

        let sb = sb.init(
            Box::try_new(PuzzlefsInfo {
                puzzlefs: puzzlefs.clone(),
            })?,
            &fs::SuperParams {
                magic: 0x72757374,
                ..fs::SuperParams::DEFAULT
            },
        )?;

        let root_inode = Arc::try_new(puzzlefs.find_inode(1)?)?;

        let root = try_new_populated_root_puzzlefs_dentry(&sb, root_inode)?;
        let sb = sb.init_root(root)?;
        Ok(sb)
    }
}

struct FsFile;

#[vtable]
impl file::Operations for FsFile {
    // must be the same as INodeData
    type OpenData = Arc<Inode>;
    type Filesystem = PuzzleFsModule;
    // this is an Arc because Data must be ForeignOwnable and the only implementors of it are Box,
    // Arc and (); we cannot pass a reference to the read callback, so we share PuzzleFS using Arc
    type Data = Arc<PuzzleFS>;

    fn open(
        fs_info: &PuzzlefsInfo,
        _context: &Self::OpenData,
        _file: &file::File,
    ) -> Result<Self::Data> {
        Ok(fs_info.puzzlefs.clone())
    }

    fn read(
        data: ArcBorrow<'_, PuzzleFS>,
        file: &file::File,
        writer: &mut impl IoBufferWriter,
        offset: u64,
    ) -> Result<usize> {
        let inode = file.inode::<PuzzleFsModule>().ok_or(EINVAL)?.fs_data();
        let mut buf = Vec::try_with_capacity(writer.len())?;
        buf.try_resize(writer.len(), 0)?;
        let read = file_read(&data.oci, inode, offset as usize, &mut buf)?;
        buf.truncate(read);
        file::read_from_slice(&buf, writer, 0)
    }
}

fn mode_to_fs_type(inode: &Inode) -> Result<u32> {
    Ok(match inode.mode {
        InodeMode::File { .. } => file::dt_type::DT_REG,
        InodeMode::Dir { .. } => file::dt_type::DT_DIR,
        InodeMode::Fifo { .. } => file::dt_type::DT_FIFO,
        InodeMode::Chr { .. } => file::dt_type::DT_CHR,
        InodeMode::Blk { .. } => file::dt_type::DT_BLK,
        InodeMode::Lnk { .. } => file::dt_type::DT_LNK,
        InodeMode::Sock { .. } => file::dt_type::DT_SOCK,
        _ => return Err(EINVAL),
    })
}

struct FsDir;

#[vtable]
impl file::Operations for FsDir {
    // must be the same as INodeData
    type OpenData = Arc<Inode>;
    type Filesystem = PuzzleFsModule;
    // this is an Arc because Data must be ForeignOwnable and the only implementors of it are Box,
    // Arc and (); we cannot pass a reference to the read callback, so we share PuzzleFS using Arc
    type Data = Arc<PuzzleFS>;

    fn open(
        fs_info: &PuzzlefsInfo,
        _context: &Self::OpenData,
        _file: &file::File,
    ) -> Result<Self::Data> {
        Ok(fs_info.puzzlefs.clone())
    }

    fn read(
        _data: ArcBorrow<'_, PuzzleFS>,
        file: &file::File,
        writer: &mut impl IoBufferWriter,
        offset: u64,
    ) -> Result<usize> {
        file::generic_read_dir(file, writer, offset)
    }

    fn seek(
        _data: ArcBorrow<'_, PuzzleFS>,
        file: &file::File,
        offset: file::SeekFrom,
    ) -> Result<u64> {
        file::generic_file_llseek(file, offset)
    }

    fn iterate_shared(
        data: ArcBorrow<'_, PuzzleFS>,
        dir: &file::File,
        context: &mut file::DirContext,
    ) -> Result<u32> {
        let inode = dir.inode::<PuzzleFsModule>().ok_or(EINVAL)?.fs_data();
        let entries = inode.dir_entries()?;

        for (_index, DirEnt { name, ino: ino_r }) in entries
            .iter()
            .enumerate()
            .skip(context.get_pos().try_into()?)
        {
            let ino = *ino_r;
            let inode = data.find_inode(ino)?;
            let kind = mode_to_fs_type(&inode)?;

            context.dir_emit(name, ino, kind)?;
            context.advance_pos(1);
        }

        Ok(0)
    }
}
