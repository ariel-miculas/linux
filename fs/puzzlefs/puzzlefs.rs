// SPDX-License-Identifier: GPL-2.0

//! PuzzleFS, a next-generation container filesystem.

use kernel::fs::{
    address_space, dentry, dentry::DEntry, file, file::DirEntryType, file::File, inode,
    inode::INode, sb, Offset,
};
use kernel::prelude::*;
use kernel::types::{ARef, Either, Locked};
use kernel::{c_str, folio::Folio, folio::PageCache, fs, str::CString, time::UNIX_EPOCH, user};
mod puzzle;
use crate::puzzle::inode::{file_read, PuzzleFS};
use crate::puzzle::types::{DirEnt, Inode, InodeMode};
// Required by the autogenerated '_capnp.rs' files
use puzzle::{manifest_capnp, metadata_capnp};

kernel::module_fs! {
    type: PuzzleFsModule,
    name: "PuzzleFS",
    author: "Ariel Miculas",
    description: "A next-generation container filesystem",
    license: "GPL",
}

fn mode_to_fs_type(inode: &Inode) -> Result<DirEntryType> {
    Ok(match inode.mode {
        InodeMode::File { .. } => DirEntryType::Reg,
        InodeMode::Dir { .. } => DirEntryType::Dir,
        InodeMode::Fifo { .. } => DirEntryType::Fifo,
        InodeMode::Chr { .. } => DirEntryType::Chr,
        InodeMode::Blk { .. } => DirEntryType::Blk,
        InodeMode::Lnk { .. } => DirEntryType::Lnk,
        InodeMode::Sock { .. } => DirEntryType::Sock,
        _ => return Err(EINVAL),
    })
}

const DIR_FOPS: file::Ops<PuzzleFsModule> = file::Ops::new::<PuzzleFsModule>();
const DIR_IOPS: inode::Ops<PuzzleFsModule> = inode::Ops::new::<PuzzleFsModule>();
const FILE_AOPS: address_space::Ops<PuzzleFsModule> = address_space::Ops::new::<PuzzleFsModule>();

struct PuzzleFsModule;

impl PuzzleFsModule {
    fn iget(sb: &sb::SuperBlock<Self>, ino: u64) -> Result<ARef<INode<Self>>> {
        let mut new = match sb.get_or_create_inode(ino)? {
            Either::Left(existing) => return Ok(existing),
            Either::Right(new) => new,
        };

        let puzzlefs = sb.data();
        let inode = puzzlefs.find_inode(ino)?;

        let (nlink, typ) = match inode.mode {
            InodeMode::Dir { .. } => {
                new.set_iops(DIR_IOPS).set_fops(DIR_FOPS);
                (2, inode::Type::Dir)
            }
            InodeMode::File { .. } => {
                new.set_fops(file::Ops::generic_ro_file())
                    .set_aops(FILE_AOPS);
                (1, inode::Type::Reg)
            }
            InodeMode::Lnk { .. } => {
                new.set_iops(inode::Ops::simple_symlink_inode());
                let target = inode
                    .additional
                    .as_ref()
                    .ok_or(ENODATA)?
                    .symlink_target
                    .as_ref()
                    .ok_or(ENODATA)?;
                (
                    1,
                    inode::Type::Lnk(Some(CString::try_from(target.as_slice())?)),
                )
            }
            _ => return Err(ENOENT),
        };

        let size = inode.size()?;

        new.init(inode::Params {
            typ,
            mode: inode.permissions,
            size,
            blocks: (u64::try_from(size)? + 511) / 512,
            nlink,
            uid: inode.uid,
            gid: inode.gid,
            atime: UNIX_EPOCH,
            ctime: UNIX_EPOCH,
            mtime: UNIX_EPOCH,
            value: inode,
        })
    }
}

impl fs::FileSystem for PuzzleFsModule {
    type Data = Box<PuzzleFS>;
    type INodeData = Inode;
    const NAME: &'static CStr = c_str!("puzzlefs");

    fn super_params(_sb: &sb::SuperBlock<Self, sb::New>) -> Result<sb::Params<Box<PuzzleFS>>> {
        let puzzlefs = PuzzleFS::open(
            c_str!("/home/puzzlefs_oci"),
            c_str!("83aa96c40a20671edc4490cfefadbb487b2ab23dfc0570049b56f0cc49b56eaf"),
        );

        if let Err(ref e) = puzzlefs {
            pr_info!("error opening puzzlefs {e}\n");
        }

        let puzzlefs = puzzlefs?;
        Ok(sb::Params {
            magic: 0x7a7a7570,
            blocksize_bits: 12,
            maxbytes: fs::MAX_LFS_FILESIZE,
            time_gran: 1,
            data: Box::try_new(puzzlefs)?,
        })
    }

    fn init_root(sb: &sb::SuperBlock<Self>) -> Result<dentry::Root<Self>> {
        let inode = Self::iget(sb, 1)?;
        dentry::Root::try_new(inode)
    }
}

#[vtable]
impl inode::Operations for PuzzleFsModule {
    type FileSystem = Self;

    fn lookup(
        parent: &INode<Self>,
        dentry: dentry::Unhashed<'_, Self>,
    ) -> Result<Option<ARef<DEntry<Self>>>> {
        let name = dentry.name();
        if let Ok(ino) = parent.data().dir_lookup(name) {
            let inode = Self::iget(parent.super_block(), ino)?;
            dentry.splice_alias(Some(inode))
        } else {
            dentry.splice_alias(None)
        }
    }
}

struct Link;
#[vtable]
impl inode::Operations for Link {
    type FileSystem = PuzzleFsModule;

    fn get_link<'a>(
        dentry: Option<&DEntry<PuzzleFsModule>>,
        inode: &'a INode<PuzzleFsModule>,
    ) -> Result<Either<CString, &'a CStr>> {
        if dentry.is_none() {
            return Err(ECHILD);
        }

        let name_buf = inode
            .data()
            .additional
            .as_ref()
            .ok_or(ENODATA)?
            .symlink_target
            .as_ref()
            .ok_or(ENODATA)?;
        let mut name = Box::try_new_slice(name_buf.len().checked_add(1).ok_or(ENOMEM)?, b'\0')?;
        name[..name_buf.len()].copy_from_slice(&name_buf);
        Ok(Either::Left(name.try_into()?))
    }
}

#[vtable]
impl address_space::Operations for PuzzleFsModule {
    type FileSystem = Self;

    fn read_folio(_: Option<&File<Self>>, mut folio: Locked<&Folio<PageCache<Self>>>) -> Result {
        let puzzlefs = folio.inode().super_block().data();
        let inode = folio.inode().data();
        let mut buf = Vec::try_with_capacity(folio.size())?;
        buf.try_resize(folio.size(), 0)?;
        let offset = usize::try_from(folio.pos()).unwrap_or(usize::MAX);
        let nr_bytes_read = file_read(&puzzlefs.oci, inode, offset, &mut buf)?;
        buf.truncate(nr_bytes_read);

        folio.write(0, &buf[..])?;
        folio.zero_out(nr_bytes_read, folio.size() - nr_bytes_read)?;
        folio.mark_uptodate();
        folio.flush_dcache();

        Ok(())
    }
}

#[vtable]
impl file::Operations for PuzzleFsModule {
    type FileSystem = Self;

    fn seek(file: &File<Self>, offset: Offset, whence: file::Whence) -> Result<Offset> {
        file::generic_seek(file, offset, whence)
    }

    fn read(_: &File<Self>, _: &mut user::Writer, _: &mut Offset) -> Result<usize> {
        Err(EISDIR)
    }

    fn read_dir(file: &File<Self>, emitter: &mut file::DirEmitter) -> Result {
        let inode = file.inode();
        let puzzlefs = inode.super_block().data();
        let inode = inode.data();
        let entries = inode.dir_entries()?;

        for DirEnt { name, ino: ino_r } in entries.iter().skip(emitter.pos().try_into()?) {
            let ino = *ino_r;
            let inode = puzzlefs.find_inode(ino)?;
            let kind = mode_to_fs_type(&inode)?;

            if !emitter.emit(1, name, ino, kind) {
                return Ok(());
            }
        }

        Ok(())
    }
}
