// SPDX-License-Identifier: GPL-2.0

//! PuzzleFS, a next-generation container filesystem.

use kernel::fs::{
    DirEmitter, DirEntryType, INode, INodeParams, INodeType, NewSuperBlock, SuperBlock, SuperParams,
};
use kernel::prelude::*;
use kernel::{c_str, folio::LockedFolio, fs, time::UNIX_EPOCH, types::ARef, types::Either};
mod puzzle;
use crate::puzzle::inode::{file_read, PuzzleFS};
use crate::puzzle::types::{DirEnt, Inode, InodeMode};
// Required by the autogenerated '_capnp.rs' files
use puzzle::{manifest_capnp, metadata_capnp};

kernel::module_fs! {
    type: PuzzleFsModule,
    name: "PuzzleFS",
    author: "Ariel Miculas",
    description: "A next-generation container filesystem",
    license: "GPL",
}

fn mode_to_fs_type(inode: &Inode) -> Result<DirEntryType> {
    Ok(match inode.mode {
        InodeMode::File { .. } => DirEntryType::Reg,
        InodeMode::Dir { .. } => DirEntryType::Dir,
        InodeMode::Fifo { .. } => DirEntryType::Fifo,
        InodeMode::Chr { .. } => DirEntryType::Chr,
        InodeMode::Blk { .. } => DirEntryType::Blk,
        InodeMode::Lnk { .. } => DirEntryType::Lnk,
        InodeMode::Sock { .. } => DirEntryType::Sock,
        _ => return Err(EINVAL),
    })
}

struct PuzzleFsModule;
impl fs::FileSystem for PuzzleFsModule {
    type Data = Box<PuzzleFS>;
    type INodeData = Inode;
    const NAME: &'static CStr = c_str!("puzzlefs");

    fn super_params(_sb: &NewSuperBlock<Self>) -> Result<SuperParams<Self::Data>> {
        let puzzlefs = PuzzleFS::open(
            c_str!("/home/puzzlefs_oci"),
            c_str!("83aa96c40a20671edc4490cfefadbb487b2ab23dfc0570049b56f0cc49b56eaf"),
        );

        if let Err(ref e) = puzzlefs {
            pr_info!("error opening puzzlefs {e}\n");
        }

        let puzzlefs = puzzlefs?;
        Ok(SuperParams {
            magic: 0x7a7a7570,
            blocksize_bits: 12,
            maxbytes: fs::MAX_LFS_FILESIZE,
            time_gran: 1,
            data: Box::try_new(puzzlefs)?,
        })
    }

    fn init_root(sb: &SuperBlock<Self>) -> Result<ARef<INode<Self>>> {
        match sb.get_or_create_inode(1)? {
            Either::Left(existing) => Ok(existing),
            Either::Right(new) => {
                let puzzlefs = sb.data();
                let root_inode = puzzlefs.find_inode(1)?;
                new.init(INodeParams {
                    typ: INodeType::Dir,
                    mode: 0o555,
                    size: 0,
                    blocks: 0,
                    nlink: 1,
                    uid: root_inode.uid,
                    gid: root_inode.gid,
                    atime: UNIX_EPOCH,
                    ctime: UNIX_EPOCH,
                    mtime: UNIX_EPOCH,
                    value: root_inode,
                })
            }
        }
    }

    fn read_dir(inode: &INode<Self>, emitter: &mut DirEmitter) -> Result {
        let puzzlefs = inode.super_block().data();
        let inode = inode.data();
        let entries = inode.dir_entries()?;

        for DirEnt { name, ino: ino_r } in entries.iter().skip(emitter.pos().try_into()?) {
            let ino = *ino_r;
            let inode = puzzlefs.find_inode(ino)?;
            let kind = mode_to_fs_type(&inode)?;

            if !emitter.emit(1, name, ino, kind) {
                return Ok(());
            }
        }

        Ok(())
    }

    fn lookup(parent: &INode<Self>, name: &[u8]) -> Result<ARef<INode<Self>>> {
        let ino = parent.data().dir_lookup(name)?;
        let puzzlefs = parent.super_block().data();
        let inode = puzzlefs.find_inode(ino)?;
        match parent.super_block().get_or_create_inode(inode.ino)? {
            Either::Left(existing) => Ok(existing),
            Either::Right(new) => {
                let params = INodeParams {
                    typ: match &inode.mode {
                        InodeMode::File { chunks: _ } => INodeType::Reg,
                        InodeMode::Dir { dir_list: _ } => INodeType::Dir,
                        InodeMode::Lnk => INodeType::Lnk,
                        InodeMode::Sock => INodeType::Sock,
                        InodeMode::Fifo => INodeType::Fifo,
                        InodeMode::Blk { major, minor } => {
                            INodeType::Blk((*major).try_into()?, (*minor).try_into()?)
                        }
                        InodeMode::Chr { major, minor } => {
                            INodeType::Chr((*major).try_into()?, (*minor).try_into()?)
                        }
                        _ => todo!(),
                    },
                    mode: inode.permissions,
                    size: inode.size()?,
                    blocks: 0,
                    nlink: 1,
                    uid: inode.uid,
                    gid: inode.gid,
                    ctime: UNIX_EPOCH,
                    mtime: UNIX_EPOCH,
                    atime: UNIX_EPOCH,
                    value: inode,
                };
                new.init(params)
            }
        }
    }

    fn read_folio(inode: &INode<Self>, mut folio: LockedFolio<'_>) -> Result {
        let puzzlefs = inode.super_block().data();
        let inode = inode.data();
        let mut buf = Vec::try_with_capacity(folio.size())?;
        buf.try_resize(folio.size(), 0)?;
        let offset = usize::try_from(folio.pos()).unwrap_or(usize::MAX);
        let nr_bytes_read = file_read(&puzzlefs.oci, inode, offset, &mut buf)?;
        buf.truncate(nr_bytes_read);

        folio.write(0, &buf[..])?;
        folio.zero_out(nr_bytes_read, folio.size() - nr_bytes_read)?;
        folio.mark_uptodate();
        folio.flush_dcache();

        Ok(())
    }
}
