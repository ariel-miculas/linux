// SPDX-License-Identifier: GPL-2.0

//! PuzzleFS, a next-generation container filesystem.

use kernel::fs::{
    address_space, dentry, dentry::DEntry, file, file::DirEntryType, file::File, inode,
    inode::INode, sb, Offset,
};
use kernel::prelude::*;
use kernel::types::{ARef, Either, Locked};
use kernel::{c_str, folio::Folio, folio::PageCache, fs, str::CString, time::UNIX_EPOCH, user};
mod puzzle;
use crate::puzzle::inode::{file_read, PuzzleFS};
use crate::puzzle::types::{DirEnt, Inode, InodeMode};
// Required by the autogenerated '_capnp.rs' files
use puzzle::{manifest_capnp, metadata_capnp};

kernel::module_fs! {
    type: PuzzleFsModule,
    name: "PuzzleFS",
    author: "Ariel Miculas",
    description: "A next-generation container filesystem",
    license: "GPL",
}

fn mode_to_fs_type(inode: &Inode) -> Result<DirEntryType> {
    Ok(match inode.mode {
        InodeMode::File { .. } => DirEntryType::Reg,
        InodeMode::Dir { .. } => DirEntryType::Dir,
        InodeMode::Fifo { .. } => DirEntryType::Fifo,
        InodeMode::Chr { .. } => DirEntryType::Chr,
        InodeMode::Blk { .. } => DirEntryType::Blk,
        InodeMode::Lnk { .. } => DirEntryType::Lnk,
        InodeMode::Sock { .. } => DirEntryType::Sock,
        _ => return Err(EINVAL),
    })
}

#[derive(Default)]
struct PuzzleFsParams {
    oci_root_dir: Option<CString>,
    image_manifest: Option<CString>,
}

#[vtable]
impl fs::Context<Self> for PuzzleFsModule {
    type Data = Box<PuzzleFsParams>;

    kernel::define_fs_params! {Box<PuzzleFsParams>,
        {string, "oci_root_dir", |s, v| {
                                      s.oci_root_dir = Some(CString::try_from_fmt(format_args!("{v}"))?);
                                      Ok(())
                                  }},
        {string, "image_manifest", |s, v| {
                                      s.image_manifest = Some(CString::try_from_fmt(format_args!("{v}"))?);
                                      Ok(())
                                  }},
    }

    fn try_new() -> Result<Self::Data> {
        Ok(Box::new(PuzzleFsParams::default(), GFP_KERNEL)?)
    }
}

const DIR_FOPS: file::Ops<PuzzleFsModule> = file::Ops::new::<PuzzleFsModule>();
const DIR_IOPS: inode::Ops<PuzzleFsModule> = inode::Ops::new::<PuzzleFsModule>();
const FILE_AOPS: address_space::Ops<PuzzleFsModule> = address_space::Ops::new::<PuzzleFsModule>();

struct PuzzleFsModule;

impl PuzzleFsModule {
    fn iget(sb: &sb::SuperBlock<Self>, ino: u64) -> Result<ARef<INode<Self>>> {
        let mut new = match sb.get_or_create_inode(ino)? {
            Either::Left(existing) => return Ok(existing),
            Either::Right(new) => new,
        };

        let puzzlefs = sb.data();
        let inode = puzzlefs.find_inode(ino)?;

        let (nlink, typ) = match inode.mode {
            InodeMode::Dir { .. } => {
                new.set_iops(DIR_IOPS).set_fops(DIR_FOPS);
                (2, inode::Type::Dir)
            }
            InodeMode::File { .. } => {
                new.set_fops(file::Ops::generic_ro_file())
                    .set_aops(FILE_AOPS);
                (1, inode::Type::Reg)
            }
            InodeMode::Lnk { .. } => {
                new.set_iops(inode::Ops::simple_symlink_inode());
                let target = inode
                    .additional
                    .as_ref()
                    .ok_or(ENODATA)?
                    .symlink_target
                    .as_ref()
                    .ok_or(ENODATA)?;
                (
                    1,
                    inode::Type::Lnk(Some(CString::try_from(target.as_slice())?)),
                )
            }
            _ => return Err(ENOENT),
        };

        let size = inode.size()?;

        new.init(inode::Params {
            typ,
            mode: inode.permissions,
            size,
            blocks: (u64::try_from(size)? + 511) / 512,
            nlink,
            uid: inode.uid,
            gid: inode.gid,
            atime: UNIX_EPOCH,
            ctime: UNIX_EPOCH,
            mtime: UNIX_EPOCH,
            value: inode,
        })
    }
}

impl fs::FileSystem for PuzzleFsModule {
    type Context = Self;
    type Data = Box<PuzzleFS>;
    type INodeData = Inode;
    const NAME: &'static CStr = c_str!("puzzlefs");

    fn fill_super(
        data: Box<PuzzleFsParams>,
        sb: &mut sb::SuperBlock<Self, sb::New>,
        _: Option<inode::Mapper>,
    ) -> Result<Box<PuzzleFS>> {
        let Some(oci_root_dir) = data.oci_root_dir else {
            pr_err!("missing oci_root_dir parameter!\n");
            return Err(ENOTSUPP);
        };

        let Some(image_manifest) = data.image_manifest else {
            pr_err!("missing image_manifest parameter!\n");
            return Err(ENOTSUPP);
        };

        let puzzlefs = PuzzleFS::open(&oci_root_dir, &image_manifest);
        if let Err(ref e) = puzzlefs {
            pr_info!("error opening puzzlefs {e}\n");
        }

        pr_info!(
            "opened puzzlefs [{}]:[{}]\n",
            &*oci_root_dir,
            &*image_manifest
        );

        let puzzlefs = puzzlefs?;
        sb.set_magic(0x7a7a7570);
        Ok(Box::new(puzzlefs, GFP_KERNEL)?)
    }

    fn init_root(sb: &sb::SuperBlock<Self>) -> Result<dentry::Root<Self>> {
        let inode = Self::iget(sb, 1)?;
        dentry::Root::try_new(inode)
    }

    fn read_xattr(
        _dentry: &DEntry<Self>,
        inode: &INode<Self>,
        name: &CStr,
        outbuf: &mut [u8],
    ) -> Result<usize> {
        let inode = inode.data();
        let readonly = outbuf.len() == 0;
        // pr_info!("outbuf len {}\n", outbuf.len());

        if let Some(add) = &inode.additional {
            let xattr = add
                .xattrs
                .iter()
                .find(|elem| elem.key == name.as_bytes())
                .ok_or(ENODATA)?;
            if readonly {
                return Ok(xattr.val.len());
            }

            if xattr.val.len() > outbuf.len() {
                return Err(ERANGE);
            }

            outbuf[0..xattr.val.len()].copy_from_slice(xattr.val.as_slice());
            return Ok(xattr.val.len());
        }
        Err(ENODATA)
    }
}

#[vtable]
impl inode::Operations for PuzzleFsModule {
    type FileSystem = Self;

    fn lookup(
        parent: &Locked<&INode<Self>, inode::ReadSem>,
        dentry: dentry::Unhashed<'_, Self>,
    ) -> Result<Option<ARef<DEntry<Self>>>> {
        let name = dentry.name();
        if let Ok(ino) = parent.data().dir_lookup(name) {
            let inode = Self::iget(parent.super_block(), ino)?;
            dentry.splice_alias(Some(inode))
        } else {
            dentry.splice_alias(None)
        }
    }

    fn listxattr(
        inode: &INode<Self>,
        mut add_entry: impl FnMut(&[i8]) -> Result<()>,
    ) -> Result<()> {
        let inode = inode.data();

        if let Some(add) = &inode.additional {
            for xattr in &add.xattrs {
                // convert a u8 slice into an i8 slice
                let i8slice = unsafe { &*(xattr.key.as_slice() as *const _ as *const [i8]) };
                add_entry(i8slice)?;
            }
        }
        Ok(())
    }

    fn get_link<'a>(
        dentry: Option<&DEntry<PuzzleFsModule>>,
        inode: &'a INode<PuzzleFsModule>,
    ) -> Result<Either<CString, &'a CStr>> {
        if dentry.is_none() {
            return Err(ECHILD);
        }

        let name_buf = inode
            .data()
            .additional
            .as_ref()
            .ok_or(ENODATA)?
            .symlink_target
            .as_ref()
            .ok_or(ENODATA)?;
        let mut name = Box::new_slice(
            name_buf.len().checked_add(1).ok_or(ENOMEM)?,
            b'\0',
            GFP_KERNEL,
        )?;
        name[..name_buf.len()].copy_from_slice(&name_buf);
        Ok(Either::Left(name.try_into()?))
    }
}

#[vtable]
impl address_space::Operations for PuzzleFsModule {
    type FileSystem = Self;

    fn read_folio(_: Option<&File<Self>>, mut folio: Locked<&Folio<PageCache<Self>>>) -> Result {
        let puzzlefs = folio.inode().super_block().data();
        let inode = folio.inode().data();
        let mut buf = Vec::with_capacity(folio.size(), GFP_KERNEL)?;
        buf.resize(folio.size(), 0, GFP_KERNEL)?;
        let offset = usize::try_from(folio.pos()).unwrap_or(usize::MAX);
        let nr_bytes_read = file_read(&puzzlefs.oci, inode, offset, &mut buf)?;
        buf.truncate(nr_bytes_read);

        folio.write(0, &buf[..])?;
        folio.zero_out(nr_bytes_read, folio.size() - nr_bytes_read)?;
        folio.mark_uptodate();
        folio.flush_dcache();

        Ok(())
    }
}

#[vtable]
impl file::Operations for PuzzleFsModule {
    type FileSystem = Self;

    fn seek(file: &File<Self>, offset: Offset, whence: file::Whence) -> Result<Offset> {
        file::generic_seek(file, offset, whence)
    }

    fn read(_: &File<Self>, _: &mut user::Writer, _: &mut Offset) -> Result<usize> {
        Err(EISDIR)
    }

    fn read_dir(
        _file: &File<Self>,
        inode: &Locked<&INode<Self>, inode::ReadSem>,
        emitter: &mut file::DirEmitter,
    ) -> Result {
        let puzzlefs = inode.super_block().data();
        let inode = inode.data();
        let entries = inode.dir_entries()?;

        for DirEnt { name, ino: ino_r } in entries.iter().skip(emitter.pos().try_into()?) {
            let ino = *ino_r;
            let inode = puzzlefs.find_inode(ino)?;
            let kind = mode_to_fs_type(&inode)?;

            if !emitter.emit(1, name, ino, kind) {
                return Ok(());
            }
        }

        Ok(())
    }
}
